# CLAUDE.md

This file provides guidance to Claude Code when working with this repository.

## Project Overview

gChess is a Kotlin chess application using Domain-Driven Design with bounded contexts (Chess, User, Matchmaking), Hexagonal Architecture, Ktor web framework, JWT authentication, PostgreSQL, and jOOQ.

## Technology Stack

- **Language**: Kotlin 1.9.22, JVM: Java 21
- **Web**: Ktor 2.3.7 (Netty), WebSocket, JWT (auth0-jwt)
- **Database**: PostgreSQL 16+, jOOQ 3.19.6, Liquibase 4.26.0, HikariCP
- **Security**: BCrypt (jbcrypt 0.4), JWT
- **DI**: Koin 3.5.3
- **IDs**: ULID (time-sortable, URL-safe)
- **Serialization**: Kotlinx Serialization (JSON)
- **Testing**: Kotest, ArchUnit, Testcontainers
- **Docs**: OpenAPI 3.0 (REST), AsyncAPI 3.0 (WebSocket)

## Build Commands

### Database Setup (Required)
```bash
cd docker && docker-compose up -d  # PostgreSQL on localhost:5432
```
Environment variables: `DATABASE_URL`, `DATABASE_USER`, `DATABASE_PASSWORD`

### Common Commands
```bash
./gradlew build                    # Build project
./gradlew run                      # Run application (port 8080)
./gradlew unitTest                 # Unit tests
./gradlew architectureTest         # Architecture validation (ArchUnit)
./gradlew integrationTest          # Integration tests (Testcontainers)
./gradlew check                    # All tests
./gradlew generateJooq             # Regenerate jOOQ classes from schema
```

## Architecture

### Bounded Contexts (DDD + Hexagonal Architecture)

#### Chess Context (`com.gchess.chess`)
- **Domain**: `Game`, `Player`, `ChessPosition` (bitboard), `Move`, `Position`, `Piece`, `PlayerSide`, `GameStatus`
  - **Key Invariants**:
    - `Player.id: PlayerId` (ephemeral per-game) + `Player.userId: UserId` (permanent)
    - Factory: `Player.create(userId, side)` generates PlayerId
    - Chess use cases NEVER manipulate UserId - only Player objects
- **Ports**: `GameRepository`, `GameEventNotifier`
- **Services**: `ChessRules` interface, `StandardChessRules` (FIDE-compliant, bitboard-based)
- **Use Cases**: `CreateGameUseCase`, `GetGameUseCase`, `MakeMoveUseCase`
- **Infrastructure**: `GameRoutes` (REST), `PostgresGameRepository` (jOOQ), `WebSocketGameEventNotifier`

#### User Context (`com.gchess.user`)
- **Domain**: `User` (id: UserId, username, email, passwordHash), `Credentials`
- **Ports**: `UserRepository`, `PasswordHasher`
- **Use Cases**: `RegisterUserUseCase`, `LoginUseCase`, `GetUserUseCase`
- **Infrastructure**: `AuthRoutes`, `UserRoutes`, `PostgresUserRepository`, `BcryptPasswordHasher`

#### Matchmaking Context (`com.gchess.matchmaking`)
- **Domain**: `QueueEntry`, `Match` (with 5min TTL), `MatchmakingStatus`, `MatchmakingResult`
- **Ports**: `MatchmakingQueue`, `MatchRepository`, `MatchmakingNotifier`
  - **ACL Ports**: `GameCreator` (→ Chess), `UserExistenceChecker` (→ User)
- **Use Cases**: `JoinMatchmakingUseCase`, `GetMatchStatusUseCase`, `LeaveMatchmakingUseCase`, `CreateGameFromMatchUseCase`
- **Infrastructure**: `MatchmakingRoutes`, `InMemoryMatchmakingQueue` (thread-safe), `PostgresMatchRepository`
  - **ACL Adapters**: `ChessContextGameCreator`, `UserContextUserChecker`

#### Shared Kernel (`com.gchess.shared`)
- **UserId**: Permanent user identity (ULID) - used by User, Matchmaking, Chess infrastructure
- **PlayerId**: Ephemeral player identity per game (ULID) - generated by Chess domain
- **GameId**: Game identifier (ULID)

### Key Design Patterns

- **Anti-Corruption Layer (ACL)**: Protects context boundaries
  - Matchmaking → Chess: `GameCreator` creates game with Player objects
  - Matchmaking → User: `UserExistenceChecker` validates users
  - Chess is fully isolated (no dependencies on User/Matchmaking)
- **Player Object Pattern**: Separates User (permanent) from Player (game participation)
  - Player creation: Matchmaking creates Players, GameRoutes creates Players from JWT
  - Chess uses only Player objects, never UserId directly
- **Hexagonal Architecture**: Domain → Application → Infrastructure (ports & adapters)
- **Value Objects**: Immutable (Player, Move, Position, CastlingRights, QueueEntry, Match)
- **Thread Safety**: ConcurrentHashMap, ConcurrentLinkedQueue, ReentrantLock
- **Dependency Injection**: Koin (`KoinModule.kt`)

### Data Flow
```
HTTP Request + JWT → Authentication → Routes (Adapter) → Use Case → Domain Logic → ACL (if needed) → Repository
```

## Domain Model Summary

### Chess
- `Game`: id, whitePlayer, blackPlayer, currentSide, currentPlayer (derived), status, moveHistory
- `Player`: id (PlayerId), userId, side (WHITE/BLACK) - created via `Player.create(userId, side)`
- `ChessPosition`: Bitboard-based (12 bitboards: 6 types × 2 colors), FEN support
- `GameStatus`: IN_PROGRESS, CHECK, CHECKMATE, STALEMATE, DRAW

### User
- `User`: id (UserId), username (min 3), email, passwordHash (BCrypt)

### Matchmaking
- `QueueEntry`: userId, joinedAt (FIFO)
- `Match`: whiteUserId, blackUserId, gameId, matchedAt, expiresAt (5min TTL)
- `MatchmakingResult`: NotFound | Waiting(queuePosition) | Matched(gameId, yourColor)

## Chess Rules Implementation

### Move Generation & Validation
- ✅ All piece types (Pawn, Knight, Bishop, Rook, Queen, King)
- ✅ En passant, pawn promotion, castling (kingside/queenside)
- ✅ Check detection, pinned pieces
- ✅ King cannot capture protected pieces

### Game Ending
- ✅ Checkmate, Stalemate
- ✅ Fifty-move rule, Threefold repetition, Insufficient material

## API Endpoints (Port 8080)

### Authentication (Public)
- `POST /api/auth/register` - Register user
- `POST /api/auth/login` - Login (returns JWT token)
- `GET /api/users/{id}` - Get user profile

### Game Operations
- `POST /api/games` - Create game (**JWT required**)
- `GET /api/games/{id}` - Get game state (Public)
- `POST /api/games/{id}/moves` - Make move (**JWT required**, body: `{"from": "e2", "to": "e4"}`)

### Matchmaking (**All require JWT**)
- `POST /api/matchmaking/queue` - Join queue (returns WAITING or MATCHED)
- `GET /api/matchmaking/status` - Poll status (poll every 2-3s)
- `DELETE /api/matchmaking/queue` - Leave queue

## WebSocket API

### Authentication
JWT required via query param: `?token=<JWT>` or `Sec-WebSocket-Protocol` header

### Endpoints

**Matchmaking**: `ws://localhost:8080/ws/matchmaking?token=<JWT>`
- Connection indexed by UserId (permanent)
- Client → Server: `{"type": "JoinQueue"}`
- Server → Client: `QueuePositionUpdate`, `MatchFound`, `MatchmakingError`
- Auto-removal from queue on disconnect

**Game**: `ws://localhost:8080/ws/game/{gameId}?token=<JWT>`
- Connection indexed by PlayerId (ephemeral per-game)
- Client → Server: `{"type": "MoveAttempt", "from": "e2", "to": "e4"}`
- Server → Client: `GameStateSync` (on connect), `MoveExecuted`, `MoveRejected`, `PlayerDisconnected`, `PlayerReconnected`
- Multi-device support (same UserId can connect to multiple games)

**Spectator**: `ws://localhost:8080/ws/game/{gameId}/spectate?token=<JWT>`
- Read-only, indexed by (GameId, UserId)
- Receives: `GameStateSync`, `MoveExecuted`, `PlayerDisconnected/Reconnected`

### Connection Managers
- `MatchmakingConnectionManager`: UserId → WebSocketSession
- `GameConnectionManager`: PlayerId → WebSocketSession
- `SpectatorConnectionManager`: GameId → Set<(UserId, WebSocketSession)>

### Domain Integration (Hexagonal)
- `MatchmakingNotifier` port → `WebSocketMatchmakingNotifier` adapter
- `GameEventNotifier` port → `WebSocketGameEventNotifier` adapter
- Best-effort notifications (failures logged, game logic unaffected)

## Security

### JWT
- **Generation**: Login returns JWT with userId claim, 24h expiration, HMAC256
- **Validation**: Ktor plugin validates signature, issuer, audience, expiration
- **Protected Routes**: Game operations, matchmaking (require `Authorization: Bearer <token>`)
- **User ID Extraction**: userId from JWT creates Player objects in GameRoutes

### Password Hashing
- BCrypt work factor 12, auto-salting, passwords never logged

## Current Limitations

- Matchmaking queue is in-memory (lost on restart; games/users persist)
- No JWT refresh mechanism
- Simple FIFO matchmaking (no ELO)
- No mutual draw agreement, no game clocks
- WebSocket reconnection is manual (no auto-recovery)

## Architecture Testing (ArchUnit)

### Hexagonal Architecture Tests
- Domain has NO dependencies on application/infrastructure
- Domain is framework-agnostic (no Ktor, Koin, serialization)
- Application depends ONLY on domain
- Naming: UseCases end with `UseCase`, Repositories with `Repository`

### Bounded Context Isolation Tests (29 tests)
- Chess domain/application CANNOT depend on User/Matchmaking
- User domain/application CANNOT depend on Chess/Matchmaking
- Matchmaking domain/application CANNOT depend on Chess/User (except shared ports)
- Only infrastructure can cross context boundaries (via ACL adapters)
- Shared Kernel: value objects only, no framework dependencies

Run: `./gradlew architectureTest`

## Integration Testing

- **Location**: `src/integrationTest/kotlin/`
- **Database**: Testcontainers PostgreSQL 16 (singleton, auto-migrations, cleanup between tests)
- **Coverage**: Full stack (REST → Use Cases → Domain → Repository), JWT auth, matchmaking flow, DTOs, HTTP status codes, ACL
- Run: `./gradlew integrationTest`

## Development Notes

- **Entry Point**: `com.gchess.Application.kt`
- **DI Wiring**: `KoinModule.kt` (all contexts + ACL adapters)
- **Database Config**: `DatabaseConfig.kt` (HikariCP, Liquibase, jOOQ DSLContext)
- **JWT Config**: `JwtConfig.kt` (HMAC256, 24h validity, env vars: JWT_SECRET, JWT_VALIDITY_MS)
- **Bitboard Engine**: 64-bit Longs, bit 0 = a1, bit 63 = h8, FEN import/export
- **Context Map**: See `CONTEXT_MAP.md` for detailed context relationships
- **Immutability**: Domain models are immutable data classes
- **Coroutines**: jOOQ calls wrapped in `withContext(Dispatchers.IO)`
